# Week 5 Feedback: Code Summarization / Comprehension

**Authors:** Xavier Schneider, Greg French, Max Ku  

## 1. Counterexample Problems

### Problem A_1: [Title]

**Task Description:**  
Describe the task clearly and precisely.

**Starter Code:**  
// Include all necessary starter code here or in a repo and share the link here.

---

### 2. Guidelines that didn't work for Problem A_1

#### Guideline 1: [Title]
**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline. 

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is not the correct/optimal answer. 

...

---

### 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 1: [Title]
**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline. 

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is the correct/optimal answer. 

...

---

### Problem B: Tic-tac-toe

### Problem B_1: Convert all existing function comments into JSDoc style comments

**Task Description:**  
For each function that has a function comment associated with it, convert the comment into a JSDoc style comment. If a function doesn't have a comment associated with it, don't add a comment to it.

Credit:
ChatGPT 5.2 generated the JavaScript code for this problem.

**Starter Code:**  
You can find all related files here: https://github.com/Xavier-Schneider/LLMs-for-Software-Engineering-Week5-Feedback

---

### Problem B_2: Add JSDoc comments to all functions

**Task Description:**  
Your next task is to add in JSDoc comments to all functions that are currently missing them.

**Starter Code:**  
You can reuse the files from B_1 for this task.

---

### Problem B_3: Summarize the code

**Task Description:**  
The final task is to summarize each function in the code file, Also provide an overview of what the code does along with any important technical information about the code that a developer should know before reading the code.

**Starter Code:**  
You can reuse the files from B_1 for this task.

---

### 2. Guidelines that didn't work for Problem B_1

#### Guideline 3: Provide a Documentation Template for the Summary 

**Prompt and Context:**  
Prompt:  
For each function that has a function comment associated with it, convert the comment into a JSDoc style comment. If a function doesn't have a comment associated with it, don't add a comment to it. Here is an example of a JSDoc style comment for a basic function:  
/**
 * Adds two numbers together.
 * @param {number} a - The first number
 * @param {number} b - The second number
 * @returns {number} The sum of a and b
 */
function add(a, b) {
  return a + b;
}

Here is an example of a JSDoc style comment for a function with an optional parameter:  
/**
 * Creates a greeting message.
 * @param {string} name - The person's name
 * @param {string} [greeting="Hello"] - Optional greeting prefix
 * @returns {string} The greeting message
 */
function greet(name, greeting = "Hello") {
  return `${greeting}, ${name}!`;
}

Context:  
https://github.com/Xavier-Schneider/LLMs-for-Software-Engineering-Week5-Feedback/tree/main/ProblemB

**Solution or Output generated by GitHub Copilot:**  
Copilot created a file called transcript.json with the following:  
```
/**
 * Perfect Tic-Tac-Toe solver (Minimax + alpha-beta pruning)
 * - Board is a length-9 array of: 'X', 'O', or null
 * - X goes first by default
 * - Returns best move for the current player
 */

// -------- Helpers --------
const LINES = [
  [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
  [0, 3, 6], [1, 4, 7], [2, 5, 8], // cols
  [0, 4, 8], [2, 4, 6],            // diags
];

function winner(board) {
  for (const [a, b, c] of LINES) {
    const v = board[a];
    if (v && v === board[b] && v === board[c]) return v; // 'X' or 'O'
  }
  return null;
}

function isDraw(board) {
  return !winner(board) && board.every(cell => cell !== null);
}

function nextPlayer(board) {
  const xCount = board.filter(v => v === 'X').length;
  const oCount = board.filter(v => v === 'O').length;
  return xCount === oCount ? 'X' : 'O';
}

function legalMoves(board) {
  const moves = [];
  for (let i = 0; i < 9; i++) if (board[i] === null) moves.push(i);
  return moves;
}

function pretty(board) {
  const s = board.map(v => v ?? ' ');
  return `
${s[0]}|${s[1]}|${s[2]}
-+-+-
${s[3]}|${s[4]}|${s[5]}
-+-+-
${s[6]}|${s[7]}|${s[8]}
`.trim();
}

/**
 * Minimax algorithm with alpha-beta pruning.
 * Scoring is from the perspective of `maximizingPlayer`.
 * Win = +10 - depth (faster win is better).
 * Loss = -10 + depth (slower loss is better).
 * Draw = 0.
 * @param {Array<'X'|'O'|null>} board - Board is a length-9 array of: 'X', 'O', or null.
 * @param {number} depth - Current search depth.
 * @param {number} alpha - Alpha value for pruning.
 * @param {number} beta - Beta value for pruning.
 * @param {'X'|'O'} maximizingPlayer - The player maximizing the score.
 * @param {'X'|'O'} currentPlayer - The current player for this node.
 * @returns {number} Score for the board from the perspective of `maximizingPlayer`.
 */
function minimax(board, depth, alpha, beta, maximizingPlayer, currentPlayer) {
  const w = winner(board);
  if (w) {
    return w === maximizingPlayer ? (10 - depth) : (-10 + depth);
  }
  if (isDraw(board)) return 0;

  const moves = legalMoves(board);

  if (currentPlayer === maximizingPlayer) {
    let best = -Infinity;
    for (const m of moves) {
      board[m] = currentPlayer;
      const score = minimax(
        board,
        depth + 1,
        alpha,
        beta,
        maximizingPlayer,
        currentPlayer === 'X' ? 'O' : 'X'
      );
      board[m] = null;
      best = Math.max(best, score);
      alpha = Math.max(alpha, best);
      if (beta <= alpha) break; // prune
    }
    return best;
  } else {
    let best = Infinity;
    for (const m of moves) {
      board[m] = currentPlayer;
      const score = minimax(
        board,
        depth + 1,
        alpha,
        beta,
        maximizingPlayer,
        currentPlayer === 'X' ? 'O' : 'X'
      );
      board[m] = null;
      best = Math.min(best, score);
      beta = Math.min(beta, best);
      if (beta <= alpha) break; // prune
    }
    return best;
  }
}

/**
 * Finds the best move for the current player on this board using minimax.
 * @param {Array<'X'|'O'|null>} board - Current board as length-9 array.
 * @returns {{move: number|null, score: number|null}} The best move index and its score, or null if game over.
 */
function bestMove(board) {
  const w = winner(board);
  if (w || isDraw(board)) return { move: null, score: null };

  const player = nextPlayer(board);
  const moves = legalMoves(board);

  let bestScore = -Infinity;
  let best = null;

  for (const m of moves) {
    board[m] = player;
    const score = minimax(
      board,
      1,
      -Infinity,
      Infinity,
      player,                       // maximize for the current player
      player === 'X' ? 'O' : 'X'    // next turn
    );
    board[m] = null;

    if (score > bestScore) {
      bestScore = score;
      best = m;
    }
  }

  return { move: best, score: bestScore };
}

// -------- Demo: AI vs AI (perfect play) --------
function playPerfectGame() {
  const board = Array(9).fill(null);

  while (!winner(board) && !isDraw(board)) {
    const { move } = bestMove(board);
    const p = nextPlayer(board);
    board[move] = p;
    console.log(`\n${p} plays ${move}\n${pretty(board)}`);
  }

  const w = winner(board);
  console.log("\nResult:", w ? `${w} wins` : "Draw");
}

// Example usage:
const board = Array(9).fill(null);
// Put some moves in to test (indexes 0..8), e.g. X at center:
board[4] = 'X';
console.log("Current board:\n" + pretty(board));
console.log("Best move for", nextPlayer(board), "=>", bestMove(board));

// Uncomment to watch perfect play:
// playPerfectGame();

```

...

**Analysis:**

ANALYSIS GOES HERE

---
